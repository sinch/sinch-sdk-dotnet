using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using Sinch.Conversation.Conversations.Create;
using Sinch.Conversation.Conversations.InjectMessage;
using Sinch.Conversation.Conversations.List;
using Sinch.Core;
using Sinch.Logger;

namespace Sinch.Conversation.Conversations
{
    /// <summary>
    ///     Endpoints for working with the conversation log.
    /// </summary>
    public interface ISinchConversationConversations
    {
        /// <summary>
        ///     Creates a new empty conversation. It is generally not needed to create a conversation explicitly since sending or
        ///     receiving a message automatically creates a new conversation if it does not already exist between the given app and
        ///     contact. Creating empty conversation is useful if the metadata of the conversation should be populated when the
        ///     first message in the conversation is a contact message or the first message in the conversation comes out-of-band
        ///     and needs to be injected with InjectMessage endpoint.
        /// </summary>
        /// <param name="request"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<Conversation> Create(CreateConversationRequest request, CancellationToken cancellationToken = default);

        /// <summary>
        ///     This operation lists all conversations that are associated with an app and/or a contact.
        /// </summary>
        /// <param name="request"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<ListConversationsResponse> List(ListConversationsRequest request,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     This operation lists all conversations automatically that are associated with an app and/or a contact.
        /// </summary>
        /// <param name="request"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        IAsyncEnumerable<Conversation> ListAuto(ListConversationsRequest request,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     Retrieves a conversation by id. A conversation has two participating entities, an app and a contact.
        /// </summary>
        /// <param name="conversationId">The unique ID of the conversation. This is generated by the system.</param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<Conversation> Get(string conversationId, CancellationToken cancellationToken = default);

        /// <summary>
        ///     Deletes a conversation together with all the messages sent as part of the conversation.
        /// </summary>
        /// <param name="conversationId">The unique ID of the conversation. This is generated by the system.</param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task Delete(string conversationId, CancellationToken cancellationToken = default);

        /// <summary>
        ///     This operation stops the referenced conversation, if the conversation is still active. A new conversation will be
        ///     created if a new message is exchanged between the app or contact that was part of the stopped conversation.
        /// </summary>
        /// <param name="conversationId">The unique ID of the conversation. This is generated by the system.</param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task Stop(string conversationId, CancellationToken cancellationToken = default);

        /// <summary>
        ///     This operation updates a conversation which can, for instance, be used to update the metadata associated with a
        ///     conversation.
        /// </summary>
        /// <param name="conversation">A conversation to update, Id should be set.</param>
        /// <param name="metadataUpdateStrategy">Update strategy for the conversation_metadata field.</param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task<Conversation> Update(Conversation conversation,
            MetadataUpdateStrategy metadataUpdateStrategy = null,
            CancellationToken cancellationToken = default);

        /// <summary>
        ///     This operation injects a conversation message in to a specific conversation.
        /// </summary>
        /// <param name="injectMessageRequest"></param>
        /// <param name="cancellationToken"></param>
        /// <returns></returns>
        Task InjectMessage(InjectMessageRequest injectMessageRequest, CancellationToken cancellationToken = default);
    }

    internal class ConversationsClient : ISinchConversationConversations
    {
        private readonly Uri _baseAddress;
        private readonly IHttp _http;
        private readonly ILoggerAdapter<ISinchConversationConversations> _logger;
        private readonly string _projectId;

        public ConversationsClient(string projectId, Uri baseAddress,
            ILoggerAdapter<ISinchConversationConversations> logger, IHttp http)
        {
            _projectId = projectId;
            _baseAddress = baseAddress;
            _logger = logger;
            _http = http;
        }

        /// <inheritdoc />
        public Task<Conversation> Create(CreateConversationRequest request,
            CancellationToken cancellationToken = default)
        {
            var uri = new Uri(_baseAddress, $"v1/projects/{_projectId}/conversations");
            _logger?.LogDebug("Creating a conversation for {project}", _projectId);
            return _http.Send<CreateConversationRequest, Conversation>(uri, HttpMethod.Post, request,
                cancellationToken);
        }

        /// <inheritdoc />
        public Task<ListConversationsResponse> List(ListConversationsRequest request,
            CancellationToken cancellationToken = default)
        {
            var uri = new Uri(_baseAddress,
                $"v1/projects/{_projectId}/conversations?{Utils.ToSnakeCaseQueryString(request)}");
            _logger?.LogDebug("Listing a conversations for {project}", _projectId);
            return _http.Send<ListConversationsResponse>(uri, HttpMethod.Get,
                cancellationToken);
        }

        /// <inheritdoc />
        public async IAsyncEnumerable<Conversation> ListAuto(ListConversationsRequest request,
            [EnumeratorCancellation] CancellationToken cancellationToken = default)
        {
            _logger?.LogDebug("Auto Listing conversations for {projectId}", _projectId);
            do
            {
                var query = Utils.ToSnakeCaseQueryString(request);
                var uri = new Uri(_baseAddress, $"/v1/projects/{_projectId}/conversations?{query}");
                var response =
                    await _http.Send<ListConversationsResponse>(uri, HttpMethod.Get, cancellationToken);
                request.PageToken = response.NextPageToken;
                foreach (var conversation in response.Conversations) yield return conversation;
            } while (!string.IsNullOrEmpty(request.PageToken));
        }

        /// <inheritdoc />
        public Task<Conversation> Get(string conversationId, CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(conversationId))
                throw new ArgumentNullException(nameof(conversationId), "Should have a value");

            var uri = new Uri(_baseAddress,
                $"v1/projects/{_projectId}/conversations/{conversationId}");
            _logger?.LogDebug("Getting a {conversationId} of {project}", conversationId, _projectId);
            return _http.Send<Conversation>(uri, HttpMethod.Get,
                cancellationToken);
        }

        /// <inheritdoc />
        public Task Delete(string conversationId, CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(conversationId))
                throw new ArgumentNullException(nameof(conversationId), "Should have a value");

            var uri = new Uri(_baseAddress,
                $"v1/projects/{_projectId}/conversations/{conversationId}");
            _logger?.LogDebug("Deleting a {conversationId} of {project}", conversationId, _projectId);
            return _http.Send<Conversation>(uri, HttpMethod.Delete,
                cancellationToken);
        }

        /// <inheritdoc />
        public Task Stop(string conversationId, CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(conversationId))
                throw new ArgumentNullException(nameof(conversationId), "Should have a value");

            var uri = new Uri(_baseAddress,
                $"v1/projects/{_projectId}/conversations/{conversationId}:stop");
            _logger?.LogDebug("Stopping a {conversationId} of {project}", conversationId, _projectId);
            return _http.Send<Conversation>(uri, HttpMethod.Delete,
                cancellationToken);
        }

        /// <inheritdoc />
        public Task<Conversation> Update(Conversation conversation,
            MetadataUpdateStrategy metadataUpdateStrategy = null,
            CancellationToken cancellationToken = default)
        {
            if (conversation == null)
                throw new ArgumentNullException(nameof(conversation), "Conversation shouldn't be null");

            if (string.IsNullOrEmpty(conversation.Id))
                throw new NullReferenceException($"{nameof(conversation.Id)} should have a value");

            var builder = new UriBuilder(new Uri(_baseAddress,
                $"v1/projects/{_projectId}/conversations/{conversation.Id}"));

            var queryString = HttpUtility.ParseQueryString(string.Empty);
            var propMask = conversation.GetPropertiesMask();
            if (!string.IsNullOrEmpty(propMask)) queryString.Add("update_mask", propMask);

            if (metadataUpdateStrategy is not null)
                queryString.Add("metadata_update_strategy", metadataUpdateStrategy.Value);

            builder.Query = queryString?.ToString()!; // it's okay to pass null.

            _logger?.LogDebug("Updating a {conversationId} of {project}", conversation.Id, _projectId);
            return _http.Send<Conversation, Conversation>(builder.Uri, HttpMethod.Patch, conversation,
                cancellationToken);
        }

        /// <inheritdoc />
        public Task InjectMessage(InjectMessageRequest injectMessageRequest,
            CancellationToken cancellationToken = default)
        {
            if (string.IsNullOrEmpty(injectMessageRequest.ConversationId))
                throw new NullReferenceException(
                    $"{nameof(injectMessageRequest)}.{nameof(injectMessageRequest.ConversationId)} should have a value");

            var uri = new Uri(_baseAddress,
                $"v1/projects/{_projectId}/conversations/{injectMessageRequest.ConversationId}:inject-message");
            _logger?.LogDebug("Injecting a message into {conversationId} of {project}",
                injectMessageRequest.ConversationId, _projectId);
            return _http.Send<InjectMessageRequest, object>(uri, HttpMethod.Post, injectMessageRequest,
                cancellationToken);
        }
    }
}
